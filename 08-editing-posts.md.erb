---
title: Editing Posts
slug: editing-posts
date: 0008/01/01
number: 8
contents: Add a form for editing your posts.|Set up edit permissions.|Restrict which properties can be edited.
paragraphs: 29
---

Nun, da wir Beiträge anlegen können ist der nächste Schritt, sie zu ändern und löschen. Weil der Code für die entsprechende UI einfach sein wird, nutzen wir die Gelegenheit um darüber zu sprechen wie Meteor mit Benutzerberechtigungen umgeht.

Zuerst verbinden wir unseren Router. Wir fügen eine Route für die Editierung des Beitrags ein und setzen den Kontext der Seite.

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});

  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postEdit', {
    path: '/posts/:_id/edit',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    if (Meteor.loggingIn())
      this.render('loading')
    else
      this.render('accessDenied');
  
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "12~15" %>

### Das Template für die Beitragsänderung

Jetzt können wir uns das Template dazu anschauen. Das Template `postEdit` ist ein ziemlich gewöhnliches Formular:

~~~html
<template name="postEdit">
  <form class="main">
    <div class="control-group">
        <label class="control-label" for="url">URL</label>
        <div class="controls">
            <input name="url" type="text" value="{{url}}" placeholder="Your URL"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="title">Title</label>
        <div class="controls">
            <input name="title" type="text" value="{{title}}" placeholder="Name your post"/>
        </div>
    </div>

    <div class="control-group">
        <div class="controls">
            <input type="submit" value="Submit" class="btn btn-primary submit"/>
        </div>
    </div>
    <hr/>
    <div class="control-group">
        <div class="controls">
            <a class="btn btn-danger delete" href="#">Delete post</a>
        </div>
    </div>
  </form>
</template>
~~~
<%= caption "client/views/posts/post_edit.html" %>

Und hier ist der Manager `post_edit.js`, der dazu gehört:

~~~js
Template.postEdit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var currentPostId = this._id;
    
    var postProperties = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val()
    }
    
    Posts.update(currentPostId, {$set: postProperties}, function(error) {
      if (error) {
        // display the error to the user
        alert(error.reason);
      } else {
        Router.go('postPage', {_id: currentPostId});
      }
    });
  },
  
  'click .delete': function(e) {
    e.preventDefault();
    
    if (confirm("Delete this post?")) {
      var currentPostId = this._id;
      Posts.remove(currentPostId);
      Router.go('postsList');
    }
  }
});
~~~
<%= caption "client/views/posts/post_edit.js" %>

Mittlerweile sollte der meiste Code dir vertraut erscheinen. Zuerst haben wir da den Template-Helper, der den derzeitigen Beitrag holt und ihn an das Template weiterleitet.

Dann gibt es zwei Event-Callbacks in dem Template: Eines für das Event `submit` und eines für das Event `click` des Links zum Löschen des Beitrages.

Der Callback zum Löschen ist sehr einfach: Das Default-Event wird verhindert. Dann wird eine Bestätigung angefordert. Wenn wir diese erhalten, wird die derzeitige Id aus dem Datenkontext des Template genommen und anhand dieser gelöscht. Am Ende wird der Benutzer zur Homepage geleitet.

Der Callback zum Aktualisieren ist ein wenig länger, aber nicht wesentlich komplizierter. Nach dem Abschalten des Default-Events und dem Ermitteln der ID des Beitrags, entnehmen wir die Werte der neuen Felder aus der Seite und speichern diese in dem Objekt `postProperties`.

Dieses Objekt übergeben wir dass an die Meteor-Methode `Collection.update()`. Mit dem Callback wird ein Fehler angezeigt, wenn die Operation fehlgeschlagen ist. Falls die Operation erfolgreich war, leitet der Callback den Benutzer zurück auf die Seite des Beitrags zurück.

### Hinzufügen von Links

Wir sollten auch Links auf unsere Beträge anlegen. Damit haben unsere Möglichkeit die Seite für das Ändern von Beiträgen zu erreichen.

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
      <p>
        submitted by {{author}}
        {{#if ownPost}}<a href="{{pathFor 'postEdit'}}">Edit</a>{{/if}}
      </p>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>
<%= highlight "5~8" %>

Natürlich wollen wir dem Benutzer nicht einen Link für einen Beitrag zeigen, der im nicht gehört. Das erledigen wir mit dem Helper `ownPost`:

~~~js
Template.postItem.helpers({
  ownPost: function() {
    return this.userId == Meteor.userId();
  },
  domain: function() {
    var a = document.createElement('a');
    a.href = this.url;
    return a.hostname;
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>
<%= highlight "2~4" %>

<%= screenshot "8-1", "Formular für das Ändern von Beiträgen." %>

<%= commit "8-1", "Added edit posts form." %>

Unser Änderungsformular für Beiträge sieht gut aus. Aber du kannst derzeit noch gar nicht die Beiträge ändern. Warum ist das so?

### Einrichtung der Berechtigungen

Da wir im letztem Kapitel das Package `insecure` entfernt haben, werden alle client-seitigen Änderungen derzeit abgewiesen.

Um das wieder gerade zu biegen, werden wir ein paar Berechtigungsregeln anlegen. Als erstes erzeuge die neue Datei `permissions.js` im Verzeichnis `lib`. Diese soll unsere Berechtigungslogik enthalten und wird immer zuerst geladen (und ist sowohl in Server- als auch in Client-Umgebung verfügbar).

~~~js
// check that the userId specified owns the documents
ownsDocument = function(userId, doc) {
  return doc && doc.userId === userId;
}
~~~
<%= caption "lib/permissions.js" %>

Im Kapitel [Creating Posts](/chapter/creating-posts), whaben wir die Methode `allow()` entfernt, weil wir neue Posts nur noch per ServerMethode angelegt haben (diese umgeht sowieso`allow()`). 

Aber jetzt, wo wir Beiträge im Client ändern und löschen, schauen wir uns noch mal die Datei `posts.js` an und fügen den folgenden Block `allow()` hinzu:

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  update: ownsDocument,
  remove: ownsDocument
});

Meteor.methods({
  ...
~~~
<%= caption "collections/posts.js" %>
<%= highlight "3~6" %>

<%= commit "8-2", "Added basic permission to check the post's owner." %>

### Einschränkung von Änderungen

////

////

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  update: ownsDocument,
  remove: ownsDocument
});

Posts.deny({
  update: function(userId, post, fieldNames) {
    // may only edit the following two fields:
    return (_.without(fieldNames, 'url', 'title').length > 0);
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "8~13" %>

<%= commit "8-3", "Only allow changing certain fields of posts." %>

////

////

<% note do %>

### Method Calls vs Client-side Data Manipulation

////

////

////

////

////

////

- ////
- ////
- ////

<% end %>

