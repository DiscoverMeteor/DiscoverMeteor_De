---
title: Beiträge verändern
slug: editing-posts
date: 0008/01/01
number: 8
contents: Erstelle ein Formular für das Ändern eines Beitrags.|Richte Zugriffsberechtigungen ein.|Schränke ein, welche Felder geändert werden dürfen.
paragraphs: 29
---

Nun können wir Beiträge anlegen. Der  nächste Schritt ist, sie zu ändern und zu löschen. Der Code für die UI ist relativ einfach. Deshalb nutzen wir die Gelegenheit, um in diesem Kapitel darüber zu sprechen, wie Meteor mit Benutzerberechtigungen umgeht.

Wir fangen damit an, unseren Router zu verbinden. Wir fügen eine Route für das Ändern von Beitragen ein und setzen den Kontext der Seite.

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});

  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postEdit', {
    path: '/posts/:_id/edit',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    if (Meteor.loggingIn())
      this.render('loading')
    else
      this.render('accessDenied');
  
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "12~15" %>

### Das Template für die Beitragsänderung

Jetzt können wir uns das Template dazu anschauen. Das Template `postEdit` ist ein ziemlich gewöhnliches Formular:

~~~html
<template name="postEdit">
  <form class="main">
    <div class="control-group">
        <label class="control-label" for="url">URL</label>
        <div class="controls">
            <input name="url" type="text" value="{{url}}" placeholder="Your URL"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="title">Title</label>
        <div class="controls">
            <input name="title" type="text" value="{{title}}" placeholder="Name your post"/>
        </div>
    </div>

    <div class="control-group">
        <div class="controls">
            <input type="submit" value="Submit" class="btn btn-primary submit"/>
        </div>
    </div>
    <hr/>
    <div class="control-group">
        <div class="controls">
            <a class="btn btn-danger delete" href="#">Delete post</a>
        </div>
    </div>
  </form>
</template>
~~~
<%= caption "client/views/posts/post_edit.html" %>

Und hier ist der dazu gehörige Manager `post_edit.js`: 

~~~js
Template.postEdit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var currentPostId = this._id;
    
    var postProperties = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val()
    }
    
    Posts.update(currentPostId, {$set: postProperties}, function(error) {
      if (error) {
        // display the error to the user
        alert(error.reason);
      } else {
        Router.go('postPage', {_id: currentPostId});
      }
    });
  },
  
  'click .delete': function(e) {
    e.preventDefault();
    
    if (confirm("Delete this post?")) {
      var currentPostId = this._id;
      Posts.remove(currentPostId);
      Router.go('postsList');
    }
  }
});
~~~
<%= caption "client/views/posts/post_edit.js" %>

Mittlerweile sollte der meiste Code davon dir vertraut erscheinen. Zuerst haben wir da den Template-Helper im Router, der den derzeitigen Beitrag holt und ihn an das Template weiterleitet.

Dann gibt es zwei Event-Callbacks in dem Template: Eines für das Event `submit` und eines für das Event `click` des Links zum Löschen des Beitrages.

Der Callback zum Löschen ist sehr einfach aufgebaut: Das Default-Event wird verhindert. Dann wird eine Bestätigung angefordert. Wenn wir diese erhalten, wird die derzeitige ID aus dem Datenkontext des Template genommen und anhand dieser gelöscht. Am Ende wird der Benutzer zur Homepage geleitet.

Der Callback zum Aktualisieren ist ein wenig länger, aber nicht wesentlich komplizierter: Nach dem Abschalten des Default-Events und dem Ermitteln der ID des Beitrags, entnehmen wir die Werte der neuen Felder aus dem Zielobjekt des Events und speichern diese in dem Objekt `postProperties`.

Dieses Objekt übergeben wir dass an die Meteor-Methode `Collection.update()`. Der Callback zeigt einen Fehler an, wenn die Operation fehlgeschlagen ist. Falls die Operation erfolgreich war, leitet der Callback den Benutzer auf die Seite des Beitrags zurück.

### Hinzufügen von Links

Es fehlen noch Links auf unsere Beträge. Mit diesen erste haben unsere Benutzer die Möglichkeit die Seite für das Ändern von Beiträgen zu erreichen.

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
      <p>
        submitted by {{author}}
        {{#if ownPost}}<a href="{{pathFor 'postEdit'}}">Edit</a>{{/if}}
      </p>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>
<%= highlight "5~8" %>

Natürlich wollen wir dem Benutzer nicht einen Link für einen Beitrag zeigen, der im nicht gehört. Das erledigen wir mit dem Helper `ownPost`:

~~~js
Template.postItem.helpers({
  ownPost: function() {
    return this.userId == Meteor.userId();
  },
  domain: function() {
    var a = document.createElement('a');
    a.href = this.url;
    return a.hostname;
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>
<%= highlight "2~4" %>

<%= screenshot "8-1", "Formular für das Ändern von Beiträgen." %>

<%= commit "8-1", "Added edit posts form." %>

Unser Änderungsformular für Beiträge sieht gut aus. Aber du kannst derzeit noch gar nicht die Beiträge ändern. Warum ist das so?

### Einrichtung der Berechtigungen

Da wir im letztem Kapitel das Package `insecure` entfernt haben, werden alle client-seitigen Änderungen derzeit abgewiesen.

Um das wieder gerade zu biegen, werden wir Berechtigungsregeln anlegen. Als erstes erzeuge die neue Datei `permissions.js` im Verzeichnis `lib`. Diese soll unsere Berechtigungslogik enthalten und wird immer zuerst geladen. Sie ist sowohl in Server- als auch in Client-Umgebung verfügbar.

~~~js
// check that the userId specified owns the documents
ownsDocument = function(userId, doc) {
  return doc && doc.userId === userId;
}
~~~
<%= caption "lib/permissions.js" %>

Im Kapitel [Beiträge anlegen](/chapter/creating-posts), haben wir die Methode `allow()` entfernt. Dies war möglich, weil wir neue Posts nur noch per Server-Methode angelegt haben (dieses Vorgehen umgeht sowieso den Mechanismus von `allow()`). 

Aber jetzt, wo wir Beiträge im Client ändern und löschen, schauen wir uns noch mal die Datei `posts.js` an. Wir fügen den folgenden Block `allow()` wieder hinzu:

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  update: ownsDocument,
  remove: ownsDocument
});

Meteor.methods({
  ...
~~~
<%= caption "collections/posts.js" %>
<%= highlight "3~6" %>

<%= commit "8-2", "Added basic permission to check the post's owner." %>

### Einschränkung von Änderungen

Nur weil du deine Beiträge ändern darfst soll das nicht heissen, dass dies für jede Eigenschaft des Beitrags gilt. Zum Beispiel wollen wir nicht, dass Benutzer das Erstellungs-Datum eines Beitrags ändern können und ihn dann jemand anders zuweisen können.

Wir benutzen hierfür Meteors Callback `deny()` um sicherzustellen, dass Benutzer nur angegebene Felder ändern können:

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  update: ownsDocument,
  remove: ownsDocument
});

Posts.deny({
  update: function(userId, post, fieldNames) {
    // may only edit the following two fields:
    return (_.without(fieldNames, 'url', 'title').length > 0);
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "8~13" %>

<%= commit "8-3", "Only allow changing certain fields of posts." %>

Wir erhalten das Array `fieldNames`, dass eine Liste der Felder enthält, die geändert werden. Durch die Verwendung von [Underscore](http://underscorejs.org/)s Methode `without()` liefern wir eine Teilmenge des Arrays zurück. In dieser fehlen die Felder, die nicht `url` oder `title` heissen.

Im Normalfall sollte das Array leer sein und eine Länge von 0 haben. Wenn jemand etwas komisches probiert, wird die Array-Länge grösser gleich 1 sein. Dadurch liefert der Callback den Wert `true` zurück (und verhindert dadurch die Änderung).

<% note do %>

### Methodenaufrufe vs. Clientseitige Datenmanipulation

Um Beiträge zu erzeugen, benutzen wir die Server-Methode `post`. Aber zum Ändern und Löschen, rufen wir die Methoden `update` und `remove` direkt auf dem Client auf und regeln die Berechtigung mit `allow` und `deny`.

Wann ist es sinnvoll das eine oder das andere zu verwenden?

Wenn der Sachverhalt einfach ist, kannst du die Regeln mit `allow` und `deny` festlegen. Es ist  meistens weniger aufwendig, diese Dinge auf dem Client zu regeln.

Das Manipulieren der Daten vom Client aus erzeugt den Anschein von Direktheit und kann zu einem besseren Benutzererlebnis beitragen - Solange du daran denkst Fehler elegant zu behandeln (zum Beispiel, wenn der Server sich asynchron zurückmeldet und mitteilt, dass die Änderung doch nicht stattgefunden hat)

Sobald du aber damit anfängst, auf dem Client Dinge zu tun auf die Benutzer keinen Zugriff haben sollen (zum Beispiel die Vergabe von Zeitstempeln oder die Zuordnung eines Benutzers), ist es wahrscheinlich besser eine Server-Methode zu verwenden.

Server-Methoden sind in folgenden Szenarien angebracht:

- Wenn Du Rückgabewerte schnell benötigst und nicht darauf warten kannst, dass diese über den Reaktivitätsmechanismus synchronisiert werden. 
- Für Datenbankoperationen, bei denen einen große Menge von Elementen geändert wird. Hierfür müssen komplette Collections hin und her übertragen werden.
- Um Daten zusammenzufassen oder zu aggregieren (z.B. Anzahl der Elemente, Mittelwerte oder Summen)

<% end %>

