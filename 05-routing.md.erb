---
title: Routing
slug: routing
date: 0005/01/01
number: 5
contents: mehr über das Routing in Meteor erfahren|die Post Diskussionsseiten mit eindeutigen URLs erstellen|lernen wie man diese URLs korrekt verlinkt.
paragraphs: 72
---

Da wir jetzt eine Liste von Posts (die am Ende von Benutzern erstellt werden) haben, brauchen wir eine eigene Post Seite, auf der Nutzer die Möglichkeit haben über jeden Post zu diskutieren.

Wir möchten diese Seiten via *Permalink* erreichbar machen, das ist eine URL der Form `http://myapp.com/posts/xyz` (`xyz` ist eine MongoDB `_id`) welche jeden Post eindeutig identifiziert.

Das bedeutet, dass wir eine Art *Routing* benötigen, um die URL aus dem Browser auszulesen und den zugehörigen Inhalt anzuzeigen.

### Hinzufügen des Iron Router Packages

[Iron Router](https://github.com/EventedMind/iron-router) ist ein Routing Package, das speziell für Meteor-Apps konzipiert wurde.

Es hilft nicht nur beim Routing (Pfade aufsetzen), sondern es kümmert sich auch um Filter (Zuweisung von Aktionen auf eben jene Pfade) und verwaltet sogar Subscriptions (Steuerung welche Route auf welche Daten zugreifen darf). (Notiz: Iron Router wurde teilweise von *Discover Meteor* co-author Tom Coleman entwickelt.)

Zunächst installieren wir das Package von Atmosphere:

~~~bash
$ meteor add iron:router
~~~
<%= caption "Terminal" %>

Dieser Befehl lädt das iron-router Package in unsere App herunter und installiert es vollständig einsatzbereit. Beachte, dass du manchmal deine Meteor-App neustarten musst, (mit `strg+c` um den Prozess zu beenden, dann `meteor` zum starten) bevor ein Package benutzt werden kann.

<% note do %>

### Router Vokabular

Wir schneiden in diesem Kapitel eine Menge verschiedener Features des Routers an. Falls du Erfahrung mit einem Framework wie z.B. Rails hast, wirst du mit den meisten Konzepten bereits vertraut sein. Falls nicht, befindet sich hier ein kleines Glossar um dir den Start zu erleichtern:

- **Routes**: Eine Route ist der Basisbaustein des Routing. Es ist im Grunde genommen die Reihe von Anweisungen, die der App mitteilt, wohin die Route zeigt und was zu tun ist, wenn sie auf eine URL trifft.
- **Paths**: Ein Pfad ist eine URL innerhalb der App. Sie kann statisch sein (`/terms_of_service`) oder dynamisch (`/posts/xyz`), und sogar Query-Parameter beinhalten (`/search?keyword=meteor`).
- **Segments**: Die einzelnen Teile des Pfades, getrennt durch Slashes (`/`).
- **Hooks**: Hooks sind Aktionen, welche du vor, nach, oder sogar während des Routing-Prozesses ausführen möchtest. Ein typisches Beispiel ist das Überprüfen der Userrechte vor dem Anzeigen einer Seite.
- **Filter**: Filter sind Hooks die global für eine oder mehrere Routen definiert werden.
- **Route Templates**: Jede Route muss auf ein Template verweisen. Wenn Du keines definierst, wird der Router nach einem Template mit dem Namen der Route suchen.
- **Layouts**: Man kann sich Layouts als Rahmen für den Inhalt vorstellen. Sie enthalten den gesamten HTML-Code welche das aktuelle Template umgeben und ändern sich nicht, selbst wenn das Template sich verändert.
- **Controller**: Manchmal wird dir auffallen, dass viele deiner Templates die gleichen Parameter benutzen. Anstelle deinen Code zu kopieren, kannst du diese Routen von einem *Routing Controller* erben lassen, welcher die gesamte Routinglogik enthält.

Für weitere Informationen zum Iron Router, schau dir [die volle Dokumentation auf GitHub](https://github.com/EventedMind/iron-router) an.

<% end %>

### Routing: URLs mit Templates verknüpfen

Bisher haben wir unser Layout mittels statischen Includes (wie z.B. `{{>postsList}}`). Also obwohl sich der Inhalt unserer App verändern kann, bleibt die grundlegende Struktur immer die Gleiche: eine Kopfzeile mit einer Liste von Posts darunter.

Iron Router ermöglicht uns aus dieser Form auszubrechen, indem er steuert, was innerhalb des HTML `<body>` Tags gerendert wird. Wir legen den Inhalt dieses Tags also nicht selbst fest, wie man das normalerweise bei einer HTML Seite machen würde. Anstatt dessen, lassen wir den Router auf ein spezielles Layout Template zeigen, das einen Template Helper anthält: `{{>yield}}`

Dieser `{{> yield}}` Helper definiert einen speziellen dynamischen Bereich, der automatisch mit dem Template gerendert wird, das der aufgerufenen Route zugeordnet ist (als Konvention bezeichnen wir dieses spezielles Template ab jetzt als "Route Template"):

<%= diagram "router-diagram", "Layouts und Templates.", "pull-center" %>

Wir beginnen damit, dass wir unser Layout erstellen und den `{{yield}}` Helper hinzufügen. Zunächst entfernen wir den HTML `<body>` Tag in der Datei `main.html` und verschieben den Inhalt in ein eigenes Template, `layout.html` (die in ein neues Verzeichnis gespeichert wird: `client/templates/application`).

Iron Router erledigt das Einbinden unseres Layouts in das gekürzte `main.html` Template, das nun so aussieht:

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

Wohingegen die neu erstelle `layout.html" nun das äußere Layout der Anwendung enthält:

~~~html
<template name="layout">
  <div class="container">
    <header class="navbar navbar-default" role="navigation">
      <div class="navbar-header">
        <a class="navbar-brand" href="/">Microscope</a>
      </div>
    </header>
    <div id="main">
      {{> yield}}
    </div>
  </div>
</template>
~~~
<%= caption "client/templates/application/layout.html" %>

Wie du bemerkt haben wirst, haben wir den Include des `postsList` Templates durch einen Aufruf des `yield` Helpers.

Nach dieser Anpassung zeigt unser Browser Tab die Standard Iron Router Hilfe-Seite. Das liegt daran, dass wir dem Router noch nicht mitgeteilt haben was er mit der `/` URL machen soll, also wird einfach ein leeres Template präsentiert.

Zuerst können wir das ursprüngliche Verhalten wieder herstellen, indem wir die URL `/` mit dem Template `postsList` verknüpfen. Wir erstellen eine neue Datei, `router.js`, innerhalb des Verzeichnisses `/lib` im Stammverzeichnis unseres Projekts.

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.route('/', {name: 'postsList'});
~~~
<%= caption "lib/router.js"%>

Wir haben zwei wichtige Dinge getan. Zuerst haben wir dem Router mitgeteilt, das gerade erstellte `layout` Template als Standard für alle Routen festzulegen.

Danach haben wir eine neue Route namens `postsList`definiert und mit dem Root Pfad `/` verknüpft.

<% note do %>

### Das `/lib` Verzeichnis

Alles, was man im `/lib` Verzeichnis ablegt, wir vor allem anderen in der App geladen (mit einem möglichen Ausnahmen, Smart Packages. Deshlab ist dies ein guter Ort um Helper Code zu speichern, der jederzeit verfügbar sein soll.

Jedoch eine kleine Warnung: beachte, dass sich der Ordner `/lib` weder im Verzeichnis `/client` noch im Verzeichnis `/server` befindet und die Inhalte somit beiden Umgebungen zur Verfügung stehen

<% end %>

### Benannte Routen

Hier gilt es eine Unklarheit zu beseitigen. Wir haben unsere Route `postsList` genannt, aber wir haben auch ein *Template* namens `postsList`. Was ist hier also los?

Standardmäßig sucht Iron Router nach einem Template vom gleichen Namen wie die Route. Tatsächlich kann er sogar vom angegebenen *Pfad* auf den Namen schließen. Auch wenn das in diesem Fall nicht funktionieren würde (da unser Pfad `/` ist), hätte Iron Router das richtige Template gefunden, wenn wir `http://localhost:3000/postsList` als Pfad genutzt hätten.

Du fragst dich vielleicht warum man Routen dann überhaupt benennen muss. Das Benennen der Routen ermöglicht es uns, einige Iron Router Features zu nutzen, die es erleichtern Links innerhalb der App zu erzeugen. Die hilfreichste Funktion ist der Spacebars Helper `{{pathFor}}`, der die URL Pfad Komponente jeder Route zurückgibt.

Wir möchten, dass unser "Home" Link uns zurück zur Posts Liste führt, also anstatt die statische URL `/` festzulegen, können wir auch den Spacebars Helper nutzen. Das Resultat ist das Gleiche, doch dieser Ansatz gibt uns mehr Flexibilität, da der Helper stets die richtige URL ausgeben wird, selbst wenn wir später einmal den Pfad der Route im Router ändern.

~~~html
<header class="navbar navbar-default" role="navigation">
  <div class="navbar-header">
    <a class="navbar-brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/templates/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### Auf Daten warten

////

////

////

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

////

////

////

////

////

////

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

////

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### A First Glance At Reactivity

////

////

////

<% end %>

### Routing To A Specific Post

////

////

////

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

////

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});

  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

////

////

////

////

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});

  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

////

////

<% note do %>

### More About Data Contexts

////

////

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

////

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

////

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Using a Dynamic Named Route Helper

////

////

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

////

////

////

////

////

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

////

////

////

<% end %>
